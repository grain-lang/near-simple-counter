/* grainc-flags --no-gc --no-pervasives */

import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import Memory from "runtime/unsafe/memory"
import { itoa64 } from "runtime/numberUtils"

// import Conv from "runtime/unsafe/conv"

import Env from "./nearEnv"

export let _KEY_PTR = 100N
export let _KEY_LEN = 8N

export let _VAL_PTR = 108N
export let _VAL_LEN = 8N

let _REG = 0N

export let setCounter = (val) => {
  // Write the value to memory.
  WasmI64.store(WasmI32.wrapI64(_VAL_PTR), val, 0n)

  // Tell the host where the key and value are located and their lengths.
  // If there is an old value it is written to _REG.

  Env.storageWrite(_KEY_LEN, _KEY_PTR, _VAL_LEN, _VAL_PTR, _REG)
  void
}

export let loadCounter = () => {
  // Check if key is in storage
  if (WasmI64.eqz(Env.storageHasKey(_KEY_LEN, _KEY_PTR))) {
    // Initialize to zero.
    0N
  } else {
    // Read the value into _REG
    Env.storageRead(_KEY_LEN, _KEY_PTR, _REG)
    // Next write the value to memory.
    // Normally wed want to use `Env.registerLen` to allocate the correct amount of space.
    // However, we already know the length of the value.
    Env.readRegister(_REG, _VAL_PTR)
    // Load the value from memory
    WasmI64.load(WasmI32.wrapI64(_VAL_PTR), 0n)
  }
}

export let counterAsStr = () => {
  let counter = loadCounter()
    itoa64(counter, 10n)
}

export let printCounter = () => {
    let str = counterAsStr()
    Env.log(str)
}
